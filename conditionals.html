---
id: null
layout: chapter
chapter: 4
title: 测试与条件
subtitle: 对不同数据执行不同命令
status: draft
description: >-
  退出代码，成功与失败，测试文件，字符串与不同条件，处理不同条件，条件运算符，条件复合命令
published: true
---

<!--
    ! 以bash指南翻译这个项目为例，可以写写过程中都有哪些因素可能会影响这个项目的执行以及结果：如远超出预期的时间投入，兴奋、兴趣的疲软，本身精神状态、情绪、睡眠的影响，freshing效果的遗失等等。

    ! 坚持只做这一件事，一方面是一心想要完成再去做别的，有偏执的因素在其中，但是这样也是努力在抓紧那根纬线，想要沉浸在bash语境中，不脱线。但是这样做也有可能就麻木在其中了，也不是身心沉浸的效果。。。
-->

<section>
    <h1>什么是条件，为什么我要使用他们？</h1>

    <p>理解条件最好的办法就是把他们实质理解为 <em>选择（choice）</em>。</p>

    <p>每当一个选择出现，我们就可以从多条不同路径中选择其一前进。每条路径都是可选的，每条都通向不同的地方。最终我们走的那条路，就取决于我们的选择。</p>

    <p>这些不像你阅读小说时碰到的选择：小说中的选择都已为你做好。小说的故事是确定了的，并没有通向其他结局的选择。条件更像是游戏中的选择：时不时地，你需要做出一个关键选择，每一个选择都会以某种方式改变游戏的境况。如果你结束游戏并重新尝试，做出不同的选择，游戏的走向就可能由此不同。我们将其称为分支。每一个选择会为我们设置一条新的分支，它会以不同的方式影响我们的环境。但是要注意，这些分支的差异并不在于<em>我们做出的选择</em>，而在于 <em>选择做出之后我们采取的行动</em>。</p>

    <p>这听起来多少有些复杂，但其实和选择买苹果手机还是安卓手机并无不同。或是选择吃早餐还是不吃。选择走高速公路还是辅路。我们考虑各个选项然后尝试做出选择。考虑我们拥有的以及给定条件下什么是最好的。条件就是这样：我们评估我们所拥有的，然后选择带着他们去向哪里。</p>

    <p>包含条件分支的脚本要远比线性脚本广阔灵活，就像游戏总是比线性叙述的书籍灵活。那么，我们为什么需要条件呢？我们需要使用他们来写出可以动态处理变化情境，根据情境改变运行方式的脚本。</p>

    <p>让我们首先从一个非常简单的条件入手，来开始我们的学习：</p>

<pre lang="bash">
<span class="prompt">$ </span><kbd>read -p "Would you like some breakfast? [y/n] "</kbd>
Would you like some breakfast? [y/n] <kbd>n</kbd>
<span class="prompt">$ </span><kbd>if [[ $REPLY = y ]]; then</kbd>
<span class="prompt">&gt; </span><kbd>    echo "Here you go, an egg sandwich."</kbd><em>Branch #1</em>
<span class="prompt">&gt; </span><kbd>else</kbd>
<span class="prompt">&gt; </span><kbd>    echo "Here, you should at least have a coffee."</kbd><em>Branch #2</em>
<span class="prompt">&gt; </span><kbd>fi</kbd>
Here, you should at least have a coffee.
</pre>

    <p>条件相比我们之前已写的所有代码，关键的不同在于现在我们写下的部分代码永远不会得到执行，除非情况发生变化。虽然第一条分支中我们也有实际的代码，但 bash 并未运行过他们，只有第二条分支中的代码会被执行。除非，情况发生了改变-对应上面例子就是我们对前面问题的回答变了，这时脚本中被执行的分支会变化，第一条分支中的代码会被运行，同时第二条分支中的代码就相应“死掉了”。</p>
<!--
    ? 上一章哪里有讲过退出代码，这里作者似乎没有讲清楚这部分。
-->
    <p>Bash 有很多种不同的方式评估条件。几乎所有这些方式都有一个共同点：他们都是基于另一个命令的退出代码被评估。因此，在深入这一章的内容之前，很重要的是你要足够熟悉上一章讨论过的退出代码。</p>
    
    <p>通常，我们通过使用复合命令，如上面例子中的 <code>if ...</code> 语句来直接评估条件。另一种方式是使用 <dfn>控制运算符 （Control Operaotr）</dfn>，我们前面章节中讨论 <dfn>List</dfn> 命令时有简单触及。我们接下来会在这里深度列举并讨论每一种条件。</p>

    <h2><code>if</code> 复合命令</h2>

    <p><code>if</code> 语句在编程语言中是如此常见，以至于每当我们考虑在代码中构建一个选择时，基本可以保证第一个就会想到它。这并不意外，这些语句清晰、简单又明确。因此也使得他们可以作为非常好的起点来熟悉 bash 中的条件。</p>

<pre class="syntax">
    <strong>if</strong> <var>list</var> [ <strong>;</strong>|<strong>&lt;newline&gt;</strong> ] <strong>then</strong> <var>list</var> <strong>;</strong>|<strong>&lt;newline&gt;</strong>
    [ <strong>elif</strong> <var>list</var> [ <strong>;</strong>|<strong>&lt;newline&gt;</strong> ] <strong>then</strong> <var>list</var> <strong>;</strong>|<strong>&lt;newline&gt;</strong> ] ...
    [ <strong>else</strong> <var>list</var> <strong>;</strong>|<strong>&lt;newline&gt;</strong> ]
    <strong>fi</strong>

<samp><u title="start of compound command 'if'">if</u> ! rm hello.txt; then <mark>echo "Couldn't delete hello.txt." &gt;&amp;2; exit 1</mark>; <u title="end of compound command 'if'">fi</u></samp>
<samp><u title="start of compound command 'if'">if</u> rm hello.txt; then <mark>echo "Successfully deleted hello.txt."</mark>
else <mark class="red">echo "Couldn't delete hello.txt." &gt;&amp;2; exit 1</mark>; <u title="end of compound command 'if'">fi</u></samp>
<samp><u title="start of compound command 'if'">if</u> mv hello.txt ~/.Trash/; then <mark>echo "Moved hello.txt into the trash."</mark>
elif rm hello.txt; then <mark class="blue">echo "Deleted hello.txt."</mark>
else <mark class="red">echo "Couldn't remove hello.txt." &gt;&amp;2; exit 1</mark>; <u title="end of compound command 'if'">fi</u></samp>
</pre>

    <p><code>if</code> 复合命令的语法虽然第一眼看起来有些冗余，实质上非常简单。首先起始于 <code>if</code> 关键词，后面跟的是一个命令列表。这个命令列表会被 bash 执行，完成后 bash 会把 退出代码发给 <code>if</code> 复合命令评估。如果退出代码是0（<code>0</code> = <dfn>成功（success）</dfn>），<em>第一条</em> 分支就会被执行，否则，第一条分支会被跳过。</p>

    <p>如果第一条分支被跳过，<code>if</code> 复合命令就会把执行的机会留给下一条分支。如果有一个或多个 <code>elif</code> 分支，他们就会相继被执行并评估各自的命令列表，如果成功，就执行他们的分支。需要注意，一旦 <code>if</code> 复合命令的任一条分支被执行，剩下的分支就会被自动跳过：即只有一条分支会被执行。如果 <code>if</code> 或是 <code>elif</code> 分支都没有可被执行的，而 <code>else</code> 分支存在，那么这条分支就会被执行。</p>

    <p>实际上，<code>if</code> 复合命令是一条语句，描述了一系列可能被执行的分支，每一条分支前都有一个命令列表，用来评估这条分支是否被选中。绝大多数 <code>if</code> 语句都只有一条分支或是一条主分支外加一条 <code>else</code> 分支。</p>

    <h2>条件命令列表（Conditional command lists）</h2>

    <p>如前所述，与其他绝大多数条件语句相似，<code>if</code> 语句会评估一个命令 <dfn>列表</dfn>最终的退出代码，从而决定它所对应的条件分支是被执行还是跳过。几乎所有你即将遇到的 <code>if</code> 和其他条件语句都是以一条 <dfn>简单命令</dfn> 作为它的条件，但也还是可以用一个简单命令列表作为条件。如果我们这样做，就一定要理解只有执行完整个命令列表后的退出代码，才会被用来评估分支是否被执行：</p>

<pre lang="bash">
<span class="prompt">$ </span><kbd>read -p "Breakfast? [y/n] "; if [[ $REPLY = y ]]; then echo "Here are your eggs."; fi</kbd>
Breakfast? [y/n] <kbd>y</kbd>
Here are your eggs.
<span class="prompt">$ </span><kbd>if read -p "Breakfast? [y/n] "; [[ $REPLY = y ]]; then echo "Here are your eggs."; fi</kbd>
Breakfast? [y/n] <kbd>y</kbd>
Here are your eggs.
</pre>

    <p>上面两个例子有完全相同的执行效果。第一个例子中，我们的 <code>read</code> 命令在 <code>if</code> 语句之前被执行；后一个例子中，<code>read</code> 命令被内嵌在初始的分支条件中。这本质上是风格或偏好的选择决定你倾向于使用哪种方法。对此的一些想法：</p>
    <ul>
        <li>将数据获取命令内嵌使得条件语句有了一种“完整”的取向E：条件成为一个单元，其内包含了它所有的依赖。</li>
        <li>数据获取命令前置于条件语句，将这两部分分成了独立的操作。当其他<code>elif</code> 分支也是语句的组成部分时，这种做法会使条件语句更为对称或者说“均衡”。</li>
    </ul>

    <h2>条件测试命令（Conditional test commands）</h2>

    <p>条件中最常见的命令是 <code>test</code> 命令，也作 <code>[</code> 命令。他们两个是同义的，只是一条命令有两个不同的名字而已。唯一的区别在于当你使用 <code>[</code> 作为命令名称时，必须用尾部参数 <code>]</code> 终止命令。</p>

    <p>然而，在当代 bash 脚本中，<code>test</code> 命令，已经因为各种原因，被后面这两个更年轻的兄弟取代了： <code>[[</code> 与 <code>((</code> 。<code>test</code> 命令已被认为是过时的，它有缺陷且脆弱的语法也完全不能与 bash 解析器赋予 <code>[[</code> 和 <code>((</code> 的特殊能力相提并论。</p>
 
    <p>乍一想可能有些奇怪，但其实是很有趣的揭示，注意看 <code>[</code> 和 <code>[[</code>，正如我们在这份指南的 <code>if</code> 以及其他示例语句中所见多次的，他们并不是 <code>if</code> 语法的特殊形式，不是的！他们就是简单、普通的命令，就像其他命令一样。<code>[[</code> 命令会获取一列参数并以参数 <code>]]</code> 终止。相似的，<code>[</code> 也是命令名称，会接收测试参数且必须以参数 <code>]</code> 结束。当我们错误省略掉命令名称与他们参数之间的空格时，这一点会尤其凸显：</p>

<pre lang="bash">
<span class="prompt">$ </span><kbd>[[ Jack = Jane ]] &amp;&amp; echo "Jack is Jane" || echo "Jack is not Jane"</kbd>
Jack is not Jane
<span class="prompt">$ </span><kbd>[[Jack = Jane ]] &amp;&amp; echo "Jack is Jane" || echo "Jack is not Jane"</kbd>
-bash: [[Jack: command not found
<span class="prompt">$ </span><kbd>[[ Jack=Jane ]] &amp;&amp; echo "Jack is Jane" || echo "Jack is not Jane"</kbd>
Jack is Jane
</pre>

    <p>第一条语句是正确的，因此我们也得到了预期的输出结果。第二条语句中，我们忘记用空格区隔 <code>[[</code> 命令 <em>名称</em> 与它后面的 <em>第一个参数</em>，导致 bash 解析器去错误寻找一个叫作 <code>[[Jack</code> 的命令。毕竟，当 bash 解析这条命令并用单词切割将命令名称和参数分作token时，第一个空格区隔开的 token 确实就是完整的字符串 <code>[[Jack</code>。</p>

    <p>第三条命令的错误可能更隐蔽。当我们有 bug 的代码导致的不是 bash 解析器错误，而只是表现怪异时，这种情况总是惊人的。这类 bug 既难以发现，也难以理解。在我们的例子中，<code>[[</code> 命令的第一个参数是一个单独的字符串 <code>Jack=Jane</code>。不幸的是，使用 <code>[[</code> 命令执行相等测试的语法是 <code class="syntax"><strong>[[</strong> <var>arg</var> <strong>=</strong> <var>arg</var> <strong>]]</strong></code>，由此 bash 才会比较两个独立的字符串参数是否相等。第三个例子中，在 <code>[[</code> 命令之后，我们并没有三个参数：我们只有一个长参数。错误结果的产生则是因为 <code>[[</code> 命令有一个测试某一字符串是否为空的简易语法：<code class="syntax"><strong>[[</strong> <var>string</var> <strong>]]</strong></code>。现在应该很明显了，bash 错误理解了我们的意图，我们是想使用 <code>=</code> 运算符比较两个字符串是否相同，bash 则以为我们是想确认某个单独的参数是否是一个空字符串。因为字符串 <code>Jack=Jane</code> <em>不为空</em>，所以测试成功，结果 <code>&amp;&amp;</code> 分支被执行。</p>

    <p>最后的总结是，一定要认识到这些测试命令本身也是 bash 命令，所以我们仍需要对他们施加标准的命令-参数间隔规则。</p>

</section>
